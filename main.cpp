#include <random>
#include <direct.h>
#include <vector>

#include "pcg/pcg_basic.h"

#define DETERMINISTIC() true

static const float c_pi = 3.14159265359f;

pcg32_random_t GetRNG_PCG()
{
    pcg32_random_t rng;
#if DETERMINISTIC()
    pcg32_srandom_r(&rng, 0x1337FEED, 0);
#else
    std::random_device device;
    std::mt19937 generator(device());
    std::uniform_int_distribution<uint32_t> dist;
    pcg32_srandom_r(&rng, dist(generator), 0);
#endif
    return rng;
}

float RandomFloat01(pcg32_random_t& rng)
{
    return float(pcg32_random_r(&rng)) / 4294967295.0f;
}

std::mt19937 GetRNG()
{
    #if DETERMINISTIC()
    std::mt19937 rng;
    #else
    std::random_device rd;
    std::mt19937 rng(rd());
    #endif
    return rng;
}

template <float XMIN, float XMAX>
struct RNG_Uniform
{
    static float PDF(float x)
    {
        if (x < XMIN || x > XMAX)
            return 0.0f;
        return 1.0f / (XMAX - XMIN);
    }

    static float Generate(std::mt19937& rng)
    {
        std::uniform_real_distribution<float> dist(XMIN, XMAX);
        return dist(rng);
    }
};

template <float SIGMA>
struct RNG_Gaussian
{
    static float PDF(float x)
    {
        return 1.0f / (SIGMA * sqrtf(2.0f * c_pi)) * exp(-x * x / (2.0f * SIGMA * SIGMA));
    }

    static float Generate(std::mt19937& rng)
    {
        std::normal_distribution<float> dist(0.0f, SIGMA);
        return dist(rng);
    }
};

// Generated by inverting the CDF
// https://blog.demofox.org/2017/08/05/generating-random-numbers-from-a-specific-distribution-by-inverting-the-cdf/
struct RNG_XSquared
{
    static float PDF(float x)
    {
        if (x < 0.0f || x > 1.0f)
            return 0.0f;
        return 3.0f * x * x;
    }

    static float Generate(std::mt19937& rng)
    {
        std::uniform_real_distribution<float> dist(0.0f, 1.0f);
        return std::cbrtf(dist(rng));
    }
};

template <typename PDF1, typename PDF2, size_t NUM_ITEMS, size_t NUM_TESTS>
void Test(const char* baseFileName)
{
    printf("%s...\n", baseFileName);
    std::mt19937 rng = GetRNG();
    pcg32_random_t rngpcg = GetRNG_PCG(); // faster

    // Generate the values
    struct Item
    {
        float value;
        float pdf1;
        float pdf2;
        float resampleWeight;
    };
    std::vector<Item> items(NUM_ITEMS);
    float resampleWeightSum = 0.0f;
    for (Item& item : items)
    {
        item.value = PDF1::Generate(rng);
        item.pdf1 = PDF1::PDF(item.value);
        item.pdf2 = PDF2::PDF(item.value);
        item.resampleWeight = item.pdf2 / item.pdf1;
        resampleWeightSum += item.resampleWeight;
    }
    for (Item& item : items)
        item.resampleWeight /= resampleWeightSum;

    printf("%f\n", resampleWeightSum);

    // Output the samples to a csv
    {
        FILE* file = nullptr;
        char fileName[1024];
        sprintf_s(fileName, "out/%s.start.csv", baseFileName);
        fopen_s(&file, fileName, "wb");
        fprintf(file, "\"Value\",\"PDF1\",\"PDF2\"\n");
        for (const Item& item : items)
            fprintf(file, "\"%f\",\"%f\",\"%f\"\n", item.value, item.pdf1, item.pdf2);
        fclose(file);
    }

    // Sample the numbers using reservoir sampling, and output them to a csv
    {
        FILE* file = nullptr;
        char fileName[1024];
        sprintf_s(fileName, "out/%s.end.csv", baseFileName);
        fopen_s(&file, fileName, "wb");
        fprintf(file, "\"Value\"\n");
        int lastPercent = -1;
        for (size_t testIndex = 0; testIndex < NUM_TESTS; ++testIndex)
        {
            int percent = int(100.0f * float(testIndex) / float(NUM_TESTS));
            if (lastPercent != percent)
            {
                lastPercent = percent;
                printf("\r%i%%", percent);
            }

            float selectedValue = 0.0f;
            float weightSum = 0.0f;

            for (size_t itemIndex = 0; itemIndex < NUM_ITEMS; ++itemIndex)
            {
                float weight = items[itemIndex].resampleWeight;
                weightSum += weight;

                float chance = weight / weightSum;
                if (RandomFloat01(rngpcg) < chance)
                    selectedValue = items[itemIndex].value;
            }
            fprintf(file, "\"%f\"\n", selectedValue);
        }
        fclose(file);
        printf("\r100%%\n");
    }
}

int main(int argc, char** argv)
{
    _mkdir("out");

    // examples of it working
    Test<RNG_Uniform<-1.0f, 1.0f>, RNG_Gaussian<0.1f>, 100000, 10000>("UniformToGaussian");
    Test<RNG_Gaussian<1.0f>, RNG_XSquared, 100000, 10000>("GaussianToXSquared");

    // examples of it failing
    Test<RNG_Uniform<-0.1f, 0.3f>, RNG_Gaussian<0.1f>, 100000, 10000>("UniformToGaussianFail");
    Test<RNG_Uniform<-1.0f, 1.0f>, RNG_Gaussian<0.1f>, 500, 10000>("UniformToGaussianFail2");

    system("python makegraphs.py");
    return 0;
}

/*

TODO:
! could maybe write out the csv's as histograms already, and could have the actual pdf along side it.
"Value","Expected Count","Actual Count"

Note:
* don't really need to normalize the resampleWeight since reservoir sampling doesn't care about it being normalized.
*/